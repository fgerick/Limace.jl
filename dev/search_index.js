var documenterSearchIndex = {"docs":
[{"location":"forces/#Forces","page":"Forces","title":"Forces","text":"","category":"section"},{"location":"forces/","page":"Forces","title":"Forces","text":"Different forces included in Limace.jl. ","category":"page"},{"location":"forces/","page":"Forces","title":"Forces","text":"So far, there is no heat equation in Limace.jl, so the forces include only the mass-term (or Limace.inertial), the Coriolis force (Limace.coriolis), the Lorentz force (Limace.lorentz) and diffusion (Limace.diffusion).  In the induction equation we have the magnetic induction term nablatimesmathbfutimesmathbfB (Limace.induction). Some details for each of these forcings is given on the respective pages.","category":"page"},{"location":"forces/#Inertial","page":"Forces","title":"Inertial","text":"","category":"section"},{"location":"forces/","page":"Forces","title":"Forces","text":"int mathbfu_i^* cdot mathbfu_jmathrmdV","category":"page"},{"location":"forces/","page":"Forces","title":"Forces","text":"Limace.inertial","category":"page"},{"location":"forces/#Limace.inertial","page":"Forces","title":"Limace.inertial","text":"inertial(\n    b::Basis;\n    external\n) -> SparseArrays.SparseMatrixCSC{ComplexF64, Int64}\n\n\nCompute the Galerkin projection matrix of basis b onto itself, i.e. the inner products.  Also known as the mass matrix.\n\n\n\n\n\n","category":"function"},{"location":"forces/#Coriolis","page":"Forces","title":"Coriolis","text":"","category":"section"},{"location":"forces/","page":"Forces","title":"Forces","text":"The necessary functions to compute Galerkin projections on the Coriolis term","category":"page"},{"location":"forces/","page":"Forces","title":"Forces","text":"int mathbfu_i^* cdot 2mathbfe_ztimesmathbfu_jmathrmdV","category":"page"},{"location":"forces/","page":"Forces","title":"Forces","text":"where mathbfu_ij are either poloidal or toroidal basis vectors.","category":"page"},{"location":"forces/","page":"Forces","title":"Forces","text":"Limace.coriolis","category":"page"},{"location":"forces/#Limace.coriolis","page":"Forces","title":"Limace.coriolis","text":"coriolis(\n    b;\n    Ω\n) -> SparseArrays.SparseMatrixCSC{ComplexF64, Int64}\n\n\nCompute the sparse Galerkin projection matrix, by projecting the basis b onto the Coriolis operator.\n\n\n\n\n\n","category":"function"},{"location":"forces/#Diffusion","page":"Forces","title":"Diffusion","text":"","category":"section"},{"location":"forces/","page":"Forces","title":"Forces","text":"int mathbfu_i^* cdot boldsymbolnabla^2mathbfu_jmathrmdV","category":"page"},{"location":"forces/","page":"Forces","title":"Forces","text":"Limace.diffusion","category":"page"},{"location":"forces/#Limace.diffusion","page":"Forces","title":"Limace.diffusion","text":"diffusion(\n    b::Basis;\n    external\n) -> SparseArrays.SparseMatrixCSC{Float64, Int64}\n\n\nCompute the Galerkin projection matrix of the basis b onto the vector Laplacian. When keyword external=true,  the integral is computed over all space, assuming continuity of the poloidal field and a scalar potential in the exterior domain.\n\n\n\n\n\n","category":"function"},{"location":"forces/#Induction","page":"Forces","title":"Induction","text":"","category":"section"},{"location":"forces/","page":"Forces","title":"Forces","text":"int mathbfb_i^* cdot boldsymbolnablatimesleft(mathbfu_jtimesmathbfB_kright)mathrmdV","category":"page"},{"location":"forces/","page":"Forces","title":"Forces","text":"Limace.induction","category":"page"},{"location":"forces/#Limace.induction","page":"Forces","title":"Limace.induction","text":"induction(\n    bbi::Basis,\n    buj::Basis,\n    B0::BasisElement{T0<:Basis, Poloidal, T};\n    external\n) -> SparseArrays.SparseMatrixCSC{Tv, Int64} where Tv\n\n\nComputes the induction term for a poloidal background magnetic field B0, a magnetic field basis bbi and a velocity basis buj.\n\n\n\n\n\ninduction(\n    bbi::Basis,\n    buj::Basis,\n    B0::BasisElement{T0<:Basis, Toroidal, T};\n    external\n) -> SparseArrays.SparseMatrixCSC{Tv, Int64} where Tv\n\n\nComputes the induction term for a toroidal background magnetic field B0, a magnetic field basis bbi and a velocity basis buj.\n\n\n\n\n\ninduction(\n    bbi::Basis,\n    U0::BasisElement{T0<:Basis, Poloidal, T},\n    bbj::Basis;\n    external\n) -> SparseArrays.SparseMatrixCSC{Tv, Int64} where Tv\n\n\nComputes the induction term for a poloidal background velocity U0, a magnetic field basis bbi and a magnetic field basis bbj.\n\n\n\n\n\ninduction(\n    bbi::Basis,\n    U0::BasisElement{T0<:Basis, Toroidal, T},\n    bbj::Basis;\n    external\n) -> SparseArrays.SparseMatrixCSC{Tv, Int64} where Tv\n\n\nComputes the induction term for a toroidal background velocity U0, a magnetic field basis bbi and a magnetic field basis bbj.\n\n\n\n\n\n","category":"function"},{"location":"forces/#Lorentz","page":"Forces","title":"Lorentz","text":"","category":"section"},{"location":"forces/","page":"Forces","title":"Forces","text":"int mathbfu_i^* cdot left(boldsymbolnablatimesmathbfb_jtimesmathbfb_kright)mathrmdV","category":"page"},{"location":"forces/","page":"Forces","title":"Forces","text":"Limace.lorentz","category":"page"},{"location":"forces/#Limace.lorentz","page":"Forces","title":"Limace.lorentz","text":"lorentz(\n    bui::Basis,\n    bbj::Basis,\n    B0::BasisElement{T0<:Basis, Poloidal, T}\n) -> SparseArrays.SparseMatrixCSC{Tv, Int64} where Tv\n\n\nComputes the Lorentz term for a poloidal background magnetic field B0, a velocity basis bui and a magnetic field basis bbj.\n\n\n\n\n\nlorentz(\n    bui::Basis,\n    bbj::Basis,\n    B0::BasisElement{T0<:Basis, Toroidal, T}\n) -> SparseArrays.SparseMatrixCSC{Tv, Int64} where Tv\n\n\nComputes the Lorentz term for a toroidal background magnetic field B0, a velocity basis bui and a magnetic field basis bbj.\n\n\n\n\n\n","category":"function"},{"location":"forces/#Explicit-boundary-condition-operator","page":"Forces","title":"Explicit boundary condition operator","text":"","category":"section"},{"location":"forces/","page":"Forces","title":"Forces","text":"Modules = [Limace]\nPages = [\"forces/bc.jl\"]","category":"page"},{"location":"forces/#Limace.boundarycondition!-Union{Tuple{T}, Tuple{TB}, Tuple{Any, TB}, Tuple{Any, TB, Type{T}}} where {TB<:Basis, T<:Number}","page":"Forces","title":"Limace.boundarycondition!","text":"boundarycondition!(A, b::Basis)\nboundarycondition!(A, b::Basis, ::Type{T<:Number})\n\n\n\n\n\n\n","category":"method"},{"location":"forces/#Limace.boundarycondition-Union{Tuple{T}, Tuple{TB}, Tuple{TB, Type{T}}} where {TB<:Basis, T<:Number}","page":"Forces","title":"Limace.boundarycondition","text":"boundarycondition(b::Number)\nboundarycondition(\n    b::Basis,\n    ::Type{T<:Number}\n) -> SparseArrays.SparseMatrixCSC{Tv, Int64} where Tv<:(Complex{T} where T<:Number)\n\n\n\n\n\n\n","category":"method"},{"location":"forces/#Limace.zero_boundarycondition!-Union{Tuple{T}, Tuple{TB}, Tuple{Any, TB}, Tuple{Any, TB, Type{T}}} where {TB<:Basis, T<:Number}","page":"Forces","title":"Limace.zero_boundarycondition!","text":"zero_boundarycondition!(A, b::Basis)\nzero_boundarycondition!(A, b::Basis, ::Type{T<:Number})\n\n\n\n\n\n\n","category":"method"},{"location":"processing/#Postprocessing","page":"Postprocessing","title":"Postprocessing","text":"","category":"section"},{"location":"processing/","page":"Postprocessing","title":"Postprocessing","text":"A non-exhaustive collection of spectral to spatial discretization and postprocessing routines.","category":"page"},{"location":"processing/","page":"Postprocessing","title":"Postprocessing","text":"Modules = [Limace.Discretization]","category":"page"},{"location":"processing/#Limace.Discretization.spectospat-Union{Tuple{Tr}, Tuple{T}, Tuple{TB}, Tuple{TU}, Tuple{Vector{T}, TU, TB, Tr, Int64, Int64}} where {TU<:Basis, TB<:Basis, T<:ComplexF64, Tr<:Union{Float64, AbstractVector{Float64}}}","page":"Postprocessing","title":"Limace.Discretization.spectospat","text":"spectospat(\n    coeffs::Array{T<:ComplexF64, 1},\n    u::Basis,\n    b::Basis,\n    r::Union{Float64, AbstractVector{Float64}},\n    nθ::Int64,\n    nϕ::Int64\n) -> Tuple{Array{T, 3} where T<:ComplexF64, Array{T, 3} where T<:ComplexF64, Array{T, 3} where T<:ComplexF64, Array{T, 3} where T<:ComplexF64, Array{T, 3} where T<:ComplexF64, Array{T, 3} where T<:ComplexF64, Vector{Float64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}\n\n\nTransform eigenvector containing spectral coefficients to two-dimensional vector fields at 1 x nθ x nϕ grid points at radius r. Returns ur,uθ,uϕ, br,bθ,bϕ, θ,ϕ.\n\n\n\n\n\n","category":"method"},{"location":"processing/#Limace.Discretization.spectospat-Union{Tuple{T}, Tuple{TB}, Tuple{TU}, Tuple{Vector{T}, TU, TB, Int64, Int64, Int64}} where {TU<:Basis, TB<:Basis, T<:ComplexF64}","page":"Postprocessing","title":"Limace.Discretization.spectospat","text":"spectospat(\n    coeffs::Array{T<:ComplexF64, 1},\n    u::Basis,\n    b::Basis,\n    nr::Int64,\n    nθ::Int64,\n    nϕ::Int64\n) -> Tuple{Array{T, 3} where T<:ComplexF64, Array{T, 3} where T<:ComplexF64, Array{T, 3} where T<:ComplexF64, Array{T, 3} where T<:ComplexF64, Array{T, 3} where T<:ComplexF64, Array{T, 3} where T<:ComplexF64, Vector{Float64}, Vector{Float64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}\n\n\nTransform eigenvector containing spectral coefficients to three-dimensional vector fields at nr x nθ x nϕ grid points at radius r. Returns ur,uθ,uϕ, br,bθ,bϕ, r,θ,ϕ.\n\n\n\n\n\n","category":"method"},{"location":"processing/#Limace.Discretization.spectospat-Union{Tuple{T}, Tuple{TU}, Tuple{Vector{T}, TU, Float64, Int64, Int64}} where {TU<:Basis, T<:ComplexF64}","page":"Postprocessing","title":"Limace.Discretization.spectospat","text":"spectospat(\n    coeffs::Array{T<:ComplexF64, 1},\n    u::Basis,\n    r::Float64,\n    nθ::Int64,\n    nϕ::Int64\n) -> Tuple{Array{T, 3} where T<:ComplexF64, Array{T, 3} where T<:ComplexF64, Array{T, 3} where T<:ComplexF64, Vector{Float64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}\n\n\nTransform eigenvector containing spectral coefficients to two-dimensional vector field at 1 x nθ x nϕ grid points at radius r. Returns ur,uθ,uϕ, θ,ϕ.\n\n\n\n\n\n","category":"method"},{"location":"processing/#Limace.Discretization.spectospat-Union{Tuple{T}, Tuple{TU}, Tuple{Vector{T}, TU, Int64, Int64, Int64}} where {TU<:Basis, T<:ComplexF64}","page":"Postprocessing","title":"Limace.Discretization.spectospat","text":"spectospat(\n    coeffs::Array{T<:ComplexF64, 1},\n    u::Basis,\n    nr::Int64,\n    nθ::Int64,\n    nϕ::Int64\n) -> Tuple{Array{T, 3} where T<:ComplexF64, Array{T, 3} where T<:ComplexF64, Array{T, 3} where T<:ComplexF64, Vector{Float64}, Vector{Float64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}\n\n\nTransform eigenvector containing spectral coefficients to three-dimensional vector field at nr x nθ x nϕ grid points. Returns ur,uθ,uϕ, r,θ,ϕ.\n\n\n\n\n\n","category":"method"},{"location":"processing/","page":"Postprocessing","title":"Postprocessing","text":"Modules = [Limace.Processing]","category":"page"},{"location":"processing/#Limace.Processing.eigenvalue_filter-Tuple{Any, Any}","page":"Postprocessing","title":"Limace.Processing.eigenvalue_filter","text":"eigenvalue_filter(\n    evals1,\n    evals2;\n    λtol\n) -> Tuple{Union{Vector{Any}, Vector{Int64}}, Union{Vector{Any}, Vector{Int64}}}\n\n\nFind all indices of evals1 and evals2 for which findall(y->any(x->isapprox(x,y; rtol=λtol), evals2),evals1). Multithreaded.\n\n\n\n\n\n","category":"method"},{"location":"processing/#Limace.Processing.ekinmags-Tuple{Any, Any, Any}","page":"Postprocessing","title":"Limace.Processing.ekinmags","text":"ekinmags(us, LHS, u) -> Tuple{Any, Any}\n\n\nCompute the kinetic and magnetic energies of all eigenvectors us, where size(us,2) is the number of eigenvalues.  LHS is the mass-matrix and u the velocity basis used in the calculation of the eigenvectors us.\n\n\n\n\n\n","category":"method"},{"location":"processing/#Limace.Processing.epeak_etrunc_cartesian-Tuple{Any, Any, Any}","page":"Postprocessing","title":"Limace.Processing.epeak_etrunc_cartesian","text":"epeak_etrunc_cartesian(evecs, u, b) -> Matrix{Float64}\n\n\nCompute the ratio of peak energy to energy at truncation degree (max between two last Cartesian degrees) in toroidal/poloidal kinetic/magnetic energy. evecs are the eigenvectors computed using the velocity basis u and magnetic field basis b.\n\n\n\n\n\n","category":"method"},{"location":"processing/#Limace.Processing.lmn_n-Union{Tuple{TB}, Tuple{TU}, Tuple{Basis{TU}, Basis{TB}}} where {TU, TB}","page":"Postprocessing","title":"Limace.Processing.lmn_n","text":"lmn_n(\n    u::Basis{TU},\n    b::Basis{TB}\n) -> Tuple{UnitRange{Int64}, Vararg{Vector, 4}}\n\n\nGet all `(l,m,n)` that correspond to the poloidal and toroidal component of `u` and `b` basis at each Cartesian\ndegree `ñ ∈ 1:N`.\n\n\n\n\n\n","category":"method"},{"location":"processing/#Limace.Processing.numerical_filter-NTuple{8, Any}","page":"Postprocessing","title":"Limace.Processing.numerical_filter","text":"numerical_filter(\n    evecs1,\n    evecs2,\n    evals1,\n    evals2,\n    u1,\n    u2,\n    b1,\n    b2;\n    threshc,\n    λtol,\n    threads,\n    epeakratiothresh,\n    kwargs...\n) -> Tuple{Union{Vector{Any}, Vector{Int64}}, Union{Vector{Any}, Vector{Int64}}}\n\n\nFind numerically converged eigensolutions between two resolutions.\n\n\n\n\n\n","category":"method"},{"location":"processing/#Limace.Processing.observability_filter-NTuple{4, Any}","page":"Postprocessing","title":"Limace.Processing.observability_filter","text":"observability_filter(\n    evals,\n    evecs,\n    u,\n    b;\n    ωlow,\n    ωhigh,\n    Qlow,\n    lthresh\n) -> Any\n\n\nFind observationally relevant solutions, based on the poloidal magnetic field.\n\n\n\n\n\n","category":"method"},{"location":"processing/#Limace.Processing.spectrum-Tuple{Any, Any, Any}","page":"Postprocessing","title":"Limace.Processing.spectrum","text":"spectrum(evecs, u, b; lmn) -> NTuple{4, Any}\n\n\nCalculate spectrum for all eigenvectors evecs comprised of velocity basis u and magnetic field basis b.  Use keyword lmn=1,2,3 to select l=1, m=2 or n=3.\n\n\n\n\n\n","category":"method"},{"location":"processing/#Limace.Processing.spectrum_cartesian-Tuple{Any, Any, Any}","page":"Postprocessing","title":"Limace.Processing.spectrum_cartesian","text":"spectrum_cartesian(evecs, u, b) -> NTuple{4, Any}\n\n\nCompute poloidal/toroidal kinetic/magnetic spectra of evecs as a function of max. Cartesian monomial degree. evecs are the eigenvectors computed using the velocity basis u and magnetic field basis b.\n\n\n\n\n\n","category":"method"},{"location":"bases/#Bases","page":"Bases","title":"Bases","text":"","category":"section"},{"location":"bases/","page":"Bases","title":"Bases","text":"Several bases are readily implemented for full sphere geometries and satisfying certain boundary and orthogonality conditions.  The most commonly encountered ones are outlined here and a small introduction into how to write a new basis is given at the end.","category":"page"},{"location":"bases/#Inviscid-velocity-basis","page":"Bases","title":"Inviscid velocity basis","text":"","category":"section"},{"location":"bases/","page":"Bases","title":"Bases","text":"For an inviscid fluid, we only require mathbfucdotmathbfn=0 at the boundary. This is known as the non-penetration condition. For poloidal and toroidal decomposition, this boils down to the requirement that the poloidal scalar vanishes at the boundary. The toroidal scalar remains unconstrained and we have free slip.","category":"page"},{"location":"bases/","page":"Bases","title":"Bases","text":"Modules = [Limace.InviscidBasis]","category":"page"},{"location":"bases/#Limace.Bases.s-Tuple{Type{Basis{Inviscid}}, Volume, Vararg{Any, 4}}","page":"Bases","title":"Limace.Bases.s","text":"s(_::Type{Basis{Inviscid}}, V::Volume, l, m, n, r) -> Any\n\n\ns_lnm(r) = f_ln(1-r^2)r^l J_n^(1l+12)(2r^2-1)\n\nwith\n\nf_ln = sqrtfrac5+2l+4n4l(l+1)(n+1)^2\n\nLivermore (2014) (5.6), normalized to unit energy. \n\n\n\n\n\n","category":"method"},{"location":"bases/#Limace.Bases.t-Tuple{Type{Basis{Inviscid}}, Volume, Vararg{Any, 4}}","page":"Bases","title":"Limace.Bases.t","text":"t(_::Type{Basis{Inviscid}}, V::Volume, l, m, n, r) -> Any\n\n\nt_lnm(r) = f_lnr^l J_n^(0l+12)(2r^2-1)\n\nwith \n\nf_ln = sqrtfrac3+2l+4nl(l+1)\n\nLivermore (2014) (5.1), normalized to unit energy.\n\n\n\n\n\n","category":"method"},{"location":"bases/#Viscous-velocity-basis","page":"Bases","title":"Viscous velocity basis","text":"","category":"section"},{"location":"bases/","page":"Bases","title":"Bases","text":"For a viscous fluid, in addition to the non-penetration condition, we require no-slip, so that in total mathbfu = mathbf0 at the boundary. Chen et al. (2018) have written a basis that satisfies these conditions, and requires orthogonality w.r.t the vector Laplacian, so that","category":"page"},{"location":"bases/","page":"Bases","title":"Bases","text":"int mathbfu_i^*cdotboldsymbolnabla^2mathbfu_jmathrmdV = delta_ij","category":"page"},{"location":"bases/","page":"Bases","title":"Bases","text":"This is desirable, as the resulting projections of all considered forces are banded (if only combined with another basis that satisfies the appropriate orthogonality).","category":"page"},{"location":"bases/","page":"Bases","title":"Bases","text":"Modules = [Limace.ViscousBasis]","category":"page"},{"location":"bases/#Limace.Bases.s-Union{Tuple{T}, Tuple{Type{Basis{Viscous}}, Volume, Any, Any, Any, T}} where T","page":"Bases","title":"Limace.Bases.s","text":"s(_::Type{Basis{Viscous}}, V::Volume, l, m, n, r) -> Any\n\n\ns_lmn = f_lnr^lleft( (2l+4n+1)J_n+1^(0l+12)(2r^2-1)-2(2l+4n+3)J_n^(0l+12)(2r^2-1) + (2l+4n+5)J_n-1^(0l+12)(2r^2-1) right)\n\nwith\n\nf_ln = left( 2l(l+1)(2l+4n+1)(2l+4n+3)(2l+4n+5) right)^-12\n\nChen et al. (2018) (2.38), (2.39) poloidal scalar, orthogonal w.r.t ∫ u⋅∇²u dV with 0 ≤ r ≤ 1.\n\n\n\n\n\n","category":"method"},{"location":"bases/#Limace.Bases.t-Tuple{Type{Basis{Viscous}}, Volume, Vararg{Any, 4}}","page":"Bases","title":"Limace.Bases.t","text":"t(_::Type{Basis{Viscous}}, V::Volume, l, m, n, r) -> Any\n\n\nt_lmn(r) = f_lnr^lleft( J_n^(0l+12)(2r^2-1) - J_n-1^(0l+12)(2r^2-1)right)\n\nwith\n\nf_ln=left(l(l+1)(2l+4n-1)+1(2l+4n+3)right)^-12\n\nChen et al. (2018) toroidal scalar, orthogonal w.r.t ∫ u⋅∇²u dV with 0 ≤ r ≤ 1.\n\n\n\n\n\n","category":"method"},{"location":"bases/#Insulating-magnetic-field-basis","page":"Bases","title":"Insulating magnetic field basis","text":"","category":"section"},{"location":"bases/","page":"Bases","title":"Bases","text":"Modules = [Limace.InsulatingBasis]","category":"page"},{"location":"bases/#Limace.Bases.s-Tuple{Type{Basis{Insulating}}, Volume, Vararg{Any, 4}}","page":"Bases","title":"Limace.Bases.s","text":"s(_::Type{Basis{Insulating}}, V::Volume, l, m, n, r) -> Any\n\n\ns_lmn(r) = f_lnr^lleft( (2l+4n+3)J_n^(0l+12)(2r^2-1) -2(2l+4n-1)J_n-1^(0l+12)(2r^2-1) + (2l+4n+1)J_n-2^(0l+12)(2r^2-1) right)\n\nwith\n\nf_ln = left( 2l(l+1)(2l+4n-3)(2l+4n-1)(2l+4n+1)right)^-12\n\nGerick and Livermore (2024) (A6)\n\n\n\n\n\n","category":"method"},{"location":"bases/#Limace.Bases.t-Tuple{Type{Basis{Insulating}}, Volume, Vararg{Any, 4}}","page":"Bases","title":"Limace.Bases.t","text":"t(_::Type{Basis{Insulating}}, V::Volume, l, m, n, r) -> Any\n\n\nt_lmn(r) = f_lnr^lleft( J_n^(0l+12)(2r^2-1) - J_n-1^(0l+12)(2r^2-1)right)\n\nwith\n\nf_ln = left( l(l+1)(2l+4n-1) + 1(2l+4n+3) right)^-12\n\nGerick and Livermore (2024) (A7)\n\n\n\n\n\n","category":"method"},{"location":"bases/#Limace.InsulatingBasis.inner_b0norm-Tuple{Any, Any}","page":"Bases","title":"Limace.InsulatingBasis.inner_b0norm","text":"inner_b0norm(\n    lmn_p,\n    lmn_t\n) -> SparseArrays.SparseMatrixCSC{ComplexF64, Int64}\n\n\nConvenience functions to normalize a B₀ that is assembled from different components to have (4π/3)⁻¹ ∫₀¹ B⋅B dV = 1 Construct Aᵢⱼ = ∫₀¹ Bᵢ ⋅Bⱼ dV \n\n\n\n\n\n","category":"method"},{"location":"bases/#Limace.InsulatingBasis.norm_B0fac!-Tuple{Any, Any, Any}","page":"Bases","title":"Limace.InsulatingBasis.norm_B0fac!","text":"norm_B0fac!(B0fac, lmn_p, lmn_t)\n\n\nNormalize B0fac (vector of scalars) corresponding to lmn_p and lmn_t basis elements. length(B0fac)=length(lmn_p)+length(lmn_t). Final array of B0fac will ensure that (4π/3)⁻¹ ∫₀¹ B⋅B dV = 1.\n\n\n\n\n\n","category":"method"},{"location":"bases/#Limace.InsulatingBasis.unitspherenorm-Tuple{Any, Any}","page":"Bases","title":"Limace.InsulatingBasis.unitspherenorm","text":"unitspherenorm(l, n) -> Any\n\n\nThe basis elements are normalized so that ∫₀^∞ B⋅B dV = 1. There is no external contribution for the toroidal components.  For the poloidal components with n=1, there is an external contribution (r>1).  To normalize the basis elements so that ∫₀¹ B⋅B dV = 1, the following norm function can be used:\n\n\n\n\n\n","category":"method"},{"location":"bases/#Unconstrained","page":"Bases","title":"Unconstrained","text":"","category":"section"},{"location":"bases/","page":"Bases","title":"Bases","text":"Modules = [Limace.UnconstrainedBasis]","category":"page"},{"location":"bases/#Limace.Bases.s-Tuple{Type{Basis{Limace.UnconstrainedBasis.Unconstrained}}, Volume, Vararg{Any, 4}}","page":"Bases","title":"Limace.Bases.s","text":"s(\n    _::Type{Basis{Limace.UnconstrainedBasis.Unconstrained}},\n    V::Volume,\n    l,\n    m,\n    n,\n    r\n) -> Any\n\n\ns_lnm(r) = f_lnr^lleft(J_n^(0l+12)(2r^2-1) - J_n-1^(0l+12)(2r^2-1) right)\n\nwith\n\nf_ln = left( l(l+1)(2l+4n+1)right)^-12\n\nLivermore (2014) (5.3), normalized to unit energy ∫u⋅u dV = 1.\n\n\n\n\n\n","category":"method"},{"location":"bases/#Limace.Bases.t-Tuple{Type{Basis{Limace.UnconstrainedBasis.Unconstrained}}, Volume, Vararg{Any, 4}}","page":"Bases","title":"Limace.Bases.t","text":"t(\n    _::Type{Basis{Limace.UnconstrainedBasis.Unconstrained}},\n    V::Volume,\n    l,\n    m,\n    n,\n    r\n) -> Any\n\n\nt_lnm(r) = f_lnr^l J_n^(0l+12)(2r^2-1)\n\nwith \n\nf_ln = sqrtfrac3+2l+4nl(l+1)\n\nLivermore (2014) (5.1), normalized to unit energy ∫u⋅u dV = 1.\n\n\n\n\n\n","category":"method"},{"location":"bases/#Implementing-a-new-basis","page":"Bases","title":"Implementing a new basis","text":"","category":"section"},{"location":"bases/","page":"Bases","title":"Bases","text":"All bases are defined in a submodule, as parametric types T of a Basis{T} basis struct and associated with a BoundaryCondition.","category":"page"},{"location":"bases/","page":"Bases","title":"Bases","text":"Modules = [Limace.Bases]","category":"page"},{"location":"bases/#Limace.Bases.Basis","page":"Bases","title":"Limace.Bases.Basis","text":"struct Basis{T}\n\nN::Int64\nm::UnitRange{Int64}\nn::UnitRange{Int64}\nBC::BoundaryCondition\nV::Volume\nparams::Dict{Symbol, Float64}\n\n\n\n\n\n","category":"type"},{"location":"bases/#Limace.Bases.BasisElement","page":"Bases","title":"Limace.Bases.BasisElement","text":"struct BasisElement{TB<:Basis, PT<:Helmholtz, T<:Number}\n\nlmn::Tuple{Int64, Int64, Int64}\nfactor::Number\n\n\n\n\n\n","category":"type"},{"location":"bases/#Limace.Bases.BoundaryCondition","page":"Bases","title":"Limace.Bases.BoundaryCondition","text":"abstract type BoundaryCondition\n\n\n\n\n\n","category":"type"},{"location":"bases/#Limace.Bases.InsulatingBC","page":"Bases","title":"Limace.Bases.InsulatingBC","text":"struct InsulatingBC <: BoundaryCondition\n\n\n\n\n\n","category":"type"},{"location":"bases/#Limace.Bases.InviscidBC","page":"Bases","title":"Limace.Bases.InviscidBC","text":"struct InviscidBC <: BoundaryCondition\n\n\n\n\n\n","category":"type"},{"location":"bases/#Limace.Bases.NoBC","page":"Bases","title":"Limace.Bases.NoBC","text":"struct NoBC <: BoundaryCondition\n\n\n\n\n\n","category":"type"},{"location":"bases/#Limace.Bases.NoSlipBC","page":"Bases","title":"Limace.Bases.NoSlipBC","text":"struct NoSlipBC <: BoundaryCondition\n\n\n\n\n\n","category":"type"},{"location":"bases/#Limace.Bases.PerfectlyConductingBC","page":"Bases","title":"Limace.Bases.PerfectlyConductingBC","text":"struct PerfectlyConductingBC <: BoundaryCondition\n\n\n\n\n\n","category":"type"},{"location":"bases/","page":"Bases","title":"Bases","text":"We can follow the example of Limace.InsulatingBasisNoBC, which implements an insulating magnetic field basis, with the boundary condition explicitly imposed afterwards.","category":"page"},{"location":"bases/","page":"Bases","title":"Bases","text":"Define a new module in a .jl file in the bases folder, and import several components of Limace.jl that are needed:","category":"page"},{"location":"bases/","page":"Bases","title":"Bases","text":"module InsulatingBasisNoBC\n\nusing SparseArrays\n\n\nusing SparseArrays\nusing LinearAlgebra\nusing DocStringExtensions\n\nusing ..Bases\nusing ..UnconstrainedBasis, ..InviscidBasis, ..InsulatingBasis\nusing ..Utils\nusing ..Poly\n\nusing ..Bases: nrange_p, nrange_t, nrange_p_bc, nrange_t_bc, np, nt, t, s, bcs_p, bcs_t, lmn_p_l, lmn_t_l, lmn_p, lmn_t, lmn2k_p_dict, lmn2k_t_dict, lpmax, ltmax, Sphere\nimport ..Bases: lpmax, ltmax, lmn_t, lmn_p, _nrange_p, _nrange_t, np, nt, t, s, nrange_p_bc, nrange_t_bc, bcs_p, bcs_t\nusing ..Poly: ∂","category":"page"},{"location":"bases/","page":"Bases","title":"Bases","text":"We define our new basis, with the right boundary condition. Here, we choose BC=NoBC(), as we impose the boundary condition explicitly afterwards.","category":"page"},{"location":"bases/","page":"Bases","title":"Bases","text":"export InsulatingNoBC\n\nstruct InsulatingNoBC end\n\nInsulatingNoBC(N; kwargs...) = Basis{InsulatingNoBC}(; N, BC=NoBC(), V=Sphere(), kwargs...)","category":"page"},{"location":"bases/","page":"Bases","title":"Bases","text":"We need to define a method for s and t for our basis. In this example, we just use the Unconstrained basis.","category":"page"},{"location":"bases/","page":"Bases","title":"Bases","text":"s(::Type{Basis{InsulatingNoBC}}, V::Volume, l,m,n,r)  = s(Basis{Unconstrained}, V, l,m,n,r) \nt(::Type{Basis{InsulatingNoBC}}, V::Volume, l,m,n,r)  = t(Basis{Unconstrained}, V, l,m,n,r) ","category":"page"},{"location":"bases/","page":"Bases","title":"Bases","text":"A few additional functions need to be defined to determine the radial and spherical harmonic degrees.","category":"page"},{"location":"bases/","page":"Bases","title":"Bases","text":"@inline _nrange_p(b::Basis{InsulatingNoBC}, l) = 0:((b.N-l+1)÷2)\n@inline _nrange_t(b::Basis{InsulatingNoBC}, l) = 0:((b.N-l)÷2)\n\n@inline lpmax(b::Basis{InsulatingNoBC}) = b.N\n@inline ltmax(b::Basis{InsulatingNoBC}) = b.N","category":"page"},{"location":"bases/","page":"Bases","title":"Bases","text":"If we have no basis imposed in the poloidal and toroidal scalars (NoBC()), we need to define the explicit boundary condition functions for the toroidal (bcs_t) and poloidal (bcs_p) scalars.","category":"page"},{"location":"bases/","page":"Bases","title":"Bases","text":"@inline function bcs_t(b::Basis{InsulatingNoBC})\n    fs = (@inline((l, n) -> t(Basis{InsulatingNoBC}, b.V, l, 0, n, 1.0)),)\n    return fs\nend\n\n@inline function bcs_p(b::Basis{InsulatingNoBC})\n    fs = (@inline((l, n) -> ∂(r -> s(Basis{InsulatingNoBC}, b.V, l, 0, n, r), 1.0) + (l + 1) * s(Basis{InsulatingNoBC}, b.V, l, 0, n, 1.0)),)\n    return fs\nend\n\nend #module","category":"page"},{"location":"bases/","page":"Bases","title":"Bases","text":"Here, these are given as evaluations at the surface, r=1.0. We use automatic differentiation to compute the derivatives in r using ForwardDiff.jl.","category":"page"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Braginsky, S. I. (1970). Torsional Magnetohydrodynamics Vibrations in the Earth's Core and Variations in Day Length. Geomagn. Aeron. 10, 3–12.\n\n\n\nBullard, E. C. and Gellman, H. (1954). Homogeneous Dynamos and Terrestrial Magnetism. Philosophical Transactions of the Royal Society of London. Series A, Mathematical and Physical Sciences 247, 213–278.\n\n\n\nChen, L.; Herreman, W.; Li, K.; Livermore, P. W.; Luo, J. W. and Jackson, A. (2018). The Optimal Kinematic Dynamo Driven by Steady Flows in a Sphere. Journal of Fluid Mechanics 839, 1–32.\n\n\n\nGerick, F. and Livermore, P. W. (2024). Interannual Magneto–Coriolis Modes and Their Sensitivity on the Magnetic Field within the Earth's Core. Proceedings of the Royal Society A: Mathematical, Physical and Engineering Sciences 480, 20240184.\n\n\n\nIvers, D. J. and Phillips, C. G. (2008). Scalar and Vector Spherical Harmonic Spectral Equations of Rotating Magnetohydrodynamics. Geophysical Journal International 175, 955–974.\n\n\n\nLivermore, P. W. (2014). A Compendium of Galerkin Orthogonal Polynomials.\n\n\n\nZhang, K.; Earnshaw, P.; Liao, X. and Busse, F. H. (2001). On Inertial Waves in a Rotating Fluid Sphere. Journal of Fluid Mechanics 437, 103–119.\n\n\n\n","category":"page"},{"location":"misc/#Misc","page":"Misc","title":"Misc","text":"","category":"section"},{"location":"misc/","page":"Misc","title":"Misc","text":"All functions/types that have not been covered elsewhere.","category":"page"},{"location":"poly/#Poly","page":"Poly","title":"Poly","text":"","category":"section"},{"location":"poly/","page":"Poly","title":"Poly","text":"Polynomial functions and conveniences.","category":"page"},{"location":"poly/","page":"Poly","title":"Poly","text":"Modules = [Limace.Poly]","category":"page"},{"location":"poly/#Limace.Poly.D-Tuple{Any, Any, Any}","page":"Poly","title":"Limace.Poly.D","text":"D(f, l, r) -> Any\n\n\nD_l(f) = fracpartial^2 fpartial r^2 +frac2rfracpartial fpartial r - fracl(l+1)r^2f\n\nBelow equation (31) in Ivers and Phillips (2008).\n\n\n\n\n\n","category":"method"},{"location":"poly/#Limace.Poly._∂ll-NTuple{4, Any}","page":"Poly","title":"Limace.Poly._∂ll","text":"_∂ll(f, l, l1, r) -> Any\n\n\npartial_l^l_1 = begincases\nfracpartial fpartial r + fracl+1rf quad mathrmif l_1 = l-1\nfracpartial fpartial r - fraclrf quad mathrmif l_1 = l+1\nendcases\n\nEquation (25) in Ivers and Phillips (2008).\n\n\n\n\n\n","category":"method"},{"location":"poly/#Limace.Poly.adamgaunt-NTuple{6, Any}","page":"Poly","title":"Limace.Poly.adamgaunt","text":"adamgaunt(la, lb, lc, ma, mb, mc) -> ComplexF64\n\n\nAdam-Gaunt integral $ A{abc} = \\oint\\int YiYjYk\\sin\\theta\\,\\mathrm{d}\\theta\\mathrm{d}\\phi$.\n\n\n\n\n\n","category":"method"},{"location":"poly/#Limace.Poly.dylmdθ-NTuple{4, Any}","page":"Poly","title":"Limace.Poly.dylmdθ","text":"dylmdθ(l, m, θ, ϕ) -> Any\n\n\nDerivative of spherical harmonic in theta.\n\n\n\n\n\n","category":"method"},{"location":"poly/#Limace.Poly.dylmdϕ-NTuple{4, Any}","page":"Poly","title":"Limace.Poly.dylmdϕ","text":"dylmdϕ(l, m, θ, ϕ) -> Any\n\n\nDerivative of spherical harmonic in phi.\n\n\n\n\n\n","category":"method"},{"location":"poly/#Limace.Poly.elsasser-NTuple{6, Any}","page":"Poly","title":"Limace.Poly.elsasser","text":"elsasser(la, lb, lc, ma, mb, mc) -> ComplexF64\n\n\nElsasser variable $ E{abc} = \\oint\\int Yk\\left( \\frac{\\partial Yi}{\\partial \\theta} \\frac{\\partial Yj}{\\partial \\phi} - \\frac{\\partial Yi}{\\partial \\phi}\\frac{\\partial Yj}{\\partial \\theta} \\right)\\,\\mathrm{d}\\theta\\mathrm{d}\\phi$.\n\n\n\n\n\n","category":"method"},{"location":"poly/#Limace.Poly.inners-NTuple{4, Any}","page":"Poly","title":"Limace.Poly.inners","text":"inners(s, s2, l, r) -> Any\n\n\nfracl(l+1)r^2left( l(l+1)s s_2 + fracpartial r spartial rfracpartial r s_2partial rright)\n\n\n\n\n\n","category":"method"},{"location":"poly/#Limace.Poly.innert-Union{Tuple{Tr}, Tuple{T2}, Tuple{T1}, Tuple{T1, T2, Int64, Tr}} where {T1, T2, Tr}","page":"Poly","title":"Limace.Poly.innert","text":"innert(t, t2, l::Int64, r) -> Any\n\n\nl(l+1)t t_2\n\n\n\n\n\n","category":"method"},{"location":"poly/#Limace.Poly.jacobi-NTuple{4, Any}","page":"Poly","title":"Limace.Poly.jacobi","text":"jacobi(n, a, b, x) -> Any\n\n\nJacobi polynomial J_n^(ab)(x).\n\n\n\n\n\n","category":"method"},{"location":"poly/#Limace.Poly.p-Tuple{Any}","page":"Poly","title":"Limace.Poly.p","text":"p(l) -> Any\n\n\np(l) = l(l+1)\n\nfollowing Ivers and Phillips (2008)\n\n\n\n\n\n","category":"method"},{"location":"poly/#Limace.Poly.ylm-Tuple{Int64, Int64, Any, Any}","page":"Poly","title":"Limace.Poly.ylm","text":"ylm(ℓ::Int64, m::Int64, θ, φ) -> Any\n\n\nSpherical harmonic in full norm, i.e. int Y_l^mY_i^j sin(theta)mathrmdthetamathrmdphi = delta_lidelta_mj.\n\n\n\n\n\n","category":"method"},{"location":"theory/#Theoretical-background","page":"Theoretical background","title":"Theoretical background","text":"","category":"section"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"Limace.jl uses a Galerkin projection method to discretize a linearized version of the non-linear rotating magnetohydrodynamic (MHD) equations, following works of Bullard and Gellman (1954), Ivers and Phillips (2008) and Gerick and Livermore (2024). For a very detailed account of all steps, the interested reader is referred to Gerick and Livermore (2024). Here, a quick and simplified overview of the mathematical and physical tools used in the model is given.","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"In non-linear form, the momentum equations of the incompressible fluid and the induction equation, are written as","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"beginalign\n\tfracpartial mathbfUpartial t + left(boldsymbolnablatimesmathbfUright)timesmathbfU + 2boldsymbolOmegatimesmathbfU = -frac1rhonabla P + frac1rhomu_0 left(boldsymbolnablatimesmathbfBright)timesmathbfB + nuboldsymbolnabla^2mathbfU + mathbfF \n\tfracpartial mathbfBpartial t = boldsymbolnablatimesleft(mathbfUtimesmathbfBright) + eta boldsymbolnabla^2mathbfB\nendalign","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"with mathbfU the velocity, mathbfB the magnetic field, boldsymbolOmega the rotation axis, rho the fluid density, P the reduced hydrodynamic pressure, mu_0 the magnetic permeability of free space, nu the kinematic viscosity, mathbfF some additional body force, and eta the magnetic diffusivitiy.","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"The velocity, magnetic and pressure fields a linearized, so that ","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"beginalign\n\tmathbfU(mathbfrt)  = mathbfU_0(mathbfr)+ mathbfu(mathbfr) e^lambda t \n\tmathbfB(mathbfrt)  = mathbfB_0(mathbfr)+ mathbfb(mathbfr) e^lambda t \n\tP(mathbfrt)    = P_0(mathbfr)+ p(mathbfr) e^lambda t\nendalign","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"with lambda=-sigma+mathrmiomega, with sigma the damping rate and omega the frequency of the oscillatory perturbation to the steady background. Removing the steady part and neglecting higher order terms, the linearized MHD equations read","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"beginalign\n\tlambdamathbfu = -left(boldsymbolnablatimesmathbfuright)timesmathbfU_0- left(boldsymbolnablatimesmathbfU_0right)timesmathbfu -2Omegamathbfe_ztimesmathbfu - frac1rhonabla p\n\t + frac1rhomu_0left(left(boldsymbolnablatimesmathbfbright)timesmathbfB_0+left(boldsymbolnablatimesmathbfB_0right)timesmathbfbright) + nu boldsymbolnabla^2mathbfunonumber\n\tlambdamathbfb = boldsymbolnablatimesleft(mathbfU_0timesmathbfbright) + boldsymbolnablatimesleft(mathbfutimesmathbfB_0right) + eta boldsymbolnabla^2mathbfb\nendalign","category":"page"},{"location":"theory/#Galerkin-projection","page":"Theoretical background","title":"Galerkin projection","text":"","category":"section"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"The linearized equations are projected onto trial vectors boldsymbolxi_i, so that","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"f_ij = int boldsymbolxi_i cdot mathbffleft(mathbfu_jmathbfb_j mathbfU_0 mathbfB_0right)mathrmdV","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"where mathbff is any of the terms in the considered MHD equations and boldsymbolxi_i = mathbfu_i mathbfb_i.","category":"page"},{"location":"theory/#Poloidal-and-toroidal-basis-vectors","page":"Theoretical background","title":"Poloidal and toroidal basis vectors","text":"","category":"section"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"Due to the divergence free condition on the velocity and magnetic field, i.e. the flow is incompressible and no magnetic monopoles,  it is convenient to decompose the fields into poloidal and toroidal components.","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"beginalign\n    mathbfu = sum_i alpha_imathbfu_i = sum_lmn alpha^P_lmnmathbfP_lmn + sum_lmn alpha^Q_lmnmathbfQ_lmn\n    mathbfb = sum_i beta_imathbfb_i =  sum_lmn beta^S_lmnmathbfS_lmn + sum_lmn beta^T_lmnmathbfT_lmn\nendalign","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"with the respective poloidal and toroidal basis vectors","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"beginalign\n\tleftmathbfPmathbfSright_lmn  = boldsymbolnablatimesboldsymbolnablatimes leftPSright_ln(r)Y_l^m(thetaphi)mathbfr \n\tleftmathbfQmathbfTright_lmn  = boldsymbolnablatimes leftQTright_ln(r) Y_l^m(thetaphi)mathbfr\nendalign","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"Here, Y_l^m is the (fully normalized) spherical harmonic of degree l and order m.","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"We therefore need to consider all combinations of poloidal and toroidal vector combinations in the projection of the forces. This leads to several long coupling terms, especially for the Lorentz force and induction term.  The integrals of these coupling terms over the spherical sourfaces can be reduced to Adam-Gaunt and Elsasser integrals, and it remains to calculate the radial integral. The detailed equations implemented in Limace.jl are given in Gerick and Livermore (2024).","category":"page"},{"location":"examples/inertialmodes/","page":"Inviscid inertial modes","title":"Inviscid inertial modes","text":"EditURL = \"../../../examples/inertialmodes.jl\"","category":"page"},{"location":"examples/inertialmodes/#Inviscid-inertial-modes-in-the-sphere","page":"Inviscid inertial modes","title":"Inviscid inertial modes in the sphere","text":"","category":"section"},{"location":"examples/inertialmodes/","page":"Inviscid inertial modes","title":"Inviscid inertial modes","text":"The evolution equation of the velocity mathbfu is given by the momentum equation","category":"page"},{"location":"examples/inertialmodes/","page":"Inviscid inertial modes","title":"Inviscid inertial modes","text":"fracpartialmathbfupartial t + 2Omega mathbfe_ztimesmathbfu = -frac1rhonabla p","category":"page"},{"location":"examples/inertialmodes/","page":"Inviscid inertial modes","title":"Inviscid inertial modes","text":"satisfying mathbfucdotmathbfn = 0 at r=1 (the surface of the sphere).","category":"page"},{"location":"examples/inertialmodes/","page":"Inviscid inertial modes","title":"Inviscid inertial modes","text":"By projecting this equation onto poloidal and toroidal basis vectors, we eliminate the pressure p.","category":"page"},{"location":"examples/inertialmodes/","page":"Inviscid inertial modes","title":"Inviscid inertial modes","text":"Assuming mathbfu(mathbfrt) = mathbfu(mathbfr) exp(lambda t), the momentum equation reduces to an eigen problem","category":"page"},{"location":"examples/inertialmodes/","page":"Inviscid inertial modes","title":"Inviscid inertial modes","text":"lambda mathbfBmathbfx = mathbfAmathbfx","category":"page"},{"location":"examples/inertialmodes/","page":"Inviscid inertial modes","title":"Inviscid inertial modes","text":"where the eigen vector mathbfx contain the spectral coefficients of the basis elements and","category":"page"},{"location":"examples/inertialmodes/","page":"Inviscid inertial modes","title":"Inviscid inertial modes","text":"B_ij = int mathbfu_i cdot mathbfu_jmathrmdV","category":"page"},{"location":"examples/inertialmodes/","page":"Inviscid inertial modes","title":"Inviscid inertial modes","text":"and","category":"page"},{"location":"examples/inertialmodes/","page":"Inviscid inertial modes","title":"Inviscid inertial modes","text":"A_ij = int mathbfu_i cdot left(2Omegamathbfe_ztimesmathbfu_jright)mathrmdV","category":"page"},{"location":"examples/inertialmodes/","page":"Inviscid inertial modes","title":"Inviscid inertial modes","text":"For moderate polynomial degrees we can quickly solve this.","category":"page"},{"location":"examples/inertialmodes/#Solve-using-Limace.jl","page":"Inviscid inertial modes","title":"Solve using Limace.jl","text":"","category":"section"},{"location":"examples/inertialmodes/","page":"Inviscid inertial modes","title":"Inviscid inertial modes","text":"First, load the packages:","category":"page"},{"location":"examples/inertialmodes/","page":"Inviscid inertial modes","title":"Inviscid inertial modes","text":"using Limace\nusing LinearAlgebra, SparseArrays, CairoMakie, GeoMakie\nusing Limace.Discretization: spectospat\nCairoMakie.activate!(; type=\"png\", px_per_unit=2)","category":"page"},{"location":"examples/inertialmodes/","page":"Inviscid inertial modes","title":"Inviscid inertial modes","text":"Define a polynomial truncation degree N.","category":"page"},{"location":"examples/inertialmodes/","page":"Inviscid inertial modes","title":"Inviscid inertial modes","text":"N = 8","category":"page"},{"location":"examples/inertialmodes/","page":"Inviscid inertial modes","title":"Inviscid inertial modes","text":"Create inviscid velocity basis. Here, we include all azimuthal wave numbers m = -N:N (we can also consider each m individually for the inviscid inertial modes).","category":"page"},{"location":"examples/inertialmodes/","page":"Inviscid inertial modes","title":"Inviscid inertial modes","text":"u = Inviscid(N)","category":"page"},{"location":"examples/inertialmodes/","page":"Inviscid inertial modes","title":"Inviscid inertial modes","text":"Assemble the matrix mathbfA of the Coriolis operator.","category":"page"},{"location":"examples/inertialmodes/","page":"Inviscid inertial modes","title":"Inviscid inertial modes","text":"A = Limace.coriolis(u)","category":"page"},{"location":"examples/inertialmodes/","page":"Inviscid inertial modes","title":"Inviscid inertial modes","text":"The inertial matrix (sometimes called mass matrix) is just the unit operator for the Inviscid basis, as it is orthonormal. Due to this orthonormality, the eigen problem reduces to a standard eigenvalue problem. We call Matrix(A) to convert the sparse matrix A to a dense one. eigen gives the dense eigenvalue spectrum. The eigenvalues λ have zero real part, i.e. no viscous damping (you can type λ by typing \\lambda<tab>).","category":"page"},{"location":"examples/inertialmodes/","page":"Inviscid inertial modes","title":"Inviscid inertial modes","text":"λ, x = eigen(Matrix(A));\nnothing #hide","category":"page"},{"location":"examples/inertialmodes/","page":"Inviscid inertial modes","title":"Inviscid inertial modes","text":"The eigenvectors are stored in a matrix x, so that λ[i]*x[:,i] ≈ A*x[:,i].","category":"page"},{"location":"examples/inertialmodes/","page":"Inviscid inertial modes","title":"Inviscid inertial modes","text":"λ[1]*x[:,1] ≈ A*x[:,1]","category":"page"},{"location":"examples/inertialmodes/","page":"Inviscid inertial modes","title":"Inviscid inertial modes","text":"We can compare some of the numerically calculated eigenvalues λ to the analytical equation given by Zhang et al. (2001) for equatorially symmetric inertial modes.","category":"page"},{"location":"examples/inertialmodes/","page":"Inviscid inertial modes","title":"Inviscid inertial modes","text":"function λ_analytical(m, n)\n\tsm = sign(m)\n\tm = abs(m)\n\treturn -sm*2 / (m + 2) * (√(1 + m * (m + 2) / (n * (2n + 2m + 1))) - 1) * im\nend;\n\nall(m->any(isapprox(λ_analytical(m,1)), λ), 1:N-1)","category":"page"},{"location":"examples/inertialmodes/","page":"Inviscid inertial modes","title":"Inviscid inertial modes","text":"Since the Inviscid basis is complete in the Cartesian polynomials, all values are exactly as the analytical value (up to machine precision). For higher values of n, the analytical equation zhang(m, n) is only an approximation and one should compare to the roots of the univariate polynomial that gives the eigenvalues of the inertial modes.","category":"page"},{"location":"examples/inertialmodes/#Visualization","page":"Inviscid inertial modes","title":"Visualization","text":"","category":"section"},{"location":"examples/inertialmodes/","page":"Inviscid inertial modes","title":"Inviscid inertial modes","text":"We can plot the velocity of the modes, for example on the surface. The azimuthal and latitudinal velocity of the mode corresponding to zhang(3,1) is shown below.","category":"page"},{"location":"examples/inertialmodes/","page":"Inviscid inertial modes","title":"Inviscid inertial modes","text":"r, nθ, nϕ = 1.0, 100, 200\n\nimode = findmin(x->abs(x-λ_analytical(3,1)), λ)[2];\n\nur, uθ, uϕ, θ, ϕ = spectospat(x[:,imode], u, r, nθ, nϕ);\n\nlet\n\tlons, lats = rad2deg.(ϕ).-180, rad2deg.(θ);\n\n\tfig = Figure(backgroundcolor = :transparent)\n\tax1 = GeoAxis(fig[1,1]; dest=\"proj=moll\", yticklabelsvisible=false, xticklabelsvisible=false, title=L\"u_\\theta\")\n\tax2 = GeoAxis(fig[1,2]; dest=\"proj=moll\", yticklabelsvisible=false, xticklabelsvisible=false, title=L\"u_\\phi\")\n\t_uθ = real.(uθ[1,:,:].+eps())\n\tumax = maximum(abs,_uθ)\n\theatmap!(ax1,lons, lats,_uθ'; colorrange=(-umax,umax), colormap=:balance)\n\n\t_uϕ = real.(uϕ[1,:,:].+eps())\n\tumax = maximum(abs,_uϕ)\n\theatmap!(ax2,lons, lats,_uϕ'; colorrange=(-umax,umax), colormap=:balance)\n\tfig\nend","category":"page"},{"location":"examples/inertialmodes/","page":"Inviscid inertial modes","title":"Inviscid inertial modes","text":"","category":"page"},{"location":"examples/inertialmodes/","page":"Inviscid inertial modes","title":"Inviscid inertial modes","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Limace","category":"page"},{"location":"#Limace.jl","page":"Home","title":"Limace.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Limace.jl, a linear model based on Galerkin projections to solve for hydromagnetic modes in rotating spheres.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To get started, you will need a working Julia environment, preferrably >=v1.10. Then, from the REPL, you can run ","category":"page"},{"location":"","page":"Home","title":"Home","text":"import Pkg; Pkg.add(\"https://github.com/fgerick/Limace.jl.git\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"This should install most of what you need to compute the basics.  To visualize the solutions you will need to install a plotting package of your choice. The examples here use Makie.jl and GeoMakie.jl. ","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To solve for modes, three steps are needed:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Definition/Choice of appropriate bases.\nAssembly of Galerkin projection matrices.\nCompute solution(s) of (generalized) eigen problem.","category":"page"},{"location":"","page":"Home","title":"Home","text":"These three steps, with some post-processing, are introduced best through the Examples.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Some Theoretical background is given, as well as some more detailed API information on the Bases and the implemented Forces.","category":"page"},{"location":"examples/torsionalmodes/","page":"Torsional Alfvén modes","title":"Torsional Alfvén modes","text":"EditURL = \"../../../examples/torsionalmodes.jl\"","category":"page"},{"location":"examples/torsionalmodes/#Torsional-Alfvén-modes","page":"Torsional Alfvén modes","title":"Torsional Alfvén modes","text":"","category":"section"},{"location":"examples/torsionalmodes/","page":"Torsional Alfvén modes","title":"Torsional Alfvén modes","text":"Torsional Alfvén modes exist when a conducting fluid is under rapid rotation, so that the rotation time t_Omega is much shorter than the Alfvén time t_A=Lsqrtmu_0rhoB_0. Put differently, the Lehnert number mathrmLe= t_Omegat_A ll 1. Then, the flow is dominated by a geostrophic balance at the leading order, and slight departures from the geostrophic balance are restored through the Lorentz force. The result are torsional Alfvén modes (or waves), that are in essence differentially rotating geostrophic cylinders, that stretch the cylindrical radial magnetic field lines that permeate them.","category":"page"},{"location":"examples/torsionalmodes/","page":"Torsional Alfvén modes","title":"Torsional Alfvén modes","text":"A one-dimensional equation can be derived in the diffusionless limit (Braginsky, 1970). Using Limace.jl, we can instead compute weakly diffusive torsional Alfvén modes as solutions to a two-dimensional problem, when the background magnetic field is axisymmetric. In this case, all azimuthal wavenumbers m decouple and we can focus on m=0.","category":"page"},{"location":"examples/torsionalmodes/","page":"Torsional Alfvén modes","title":"Torsional Alfvén modes","text":"In the following example we will solve and illustrate the gravest torsional mode, for an axisymmetric poloidal background magnetic field.","category":"page"},{"location":"examples/torsionalmodes/","page":"Torsional Alfvén modes","title":"Torsional Alfvén modes","text":"using Limace, SparseArrays, CairoMakie\nusing Limace.EigenProblem: eigstarget\nusing Limace.Discretization: spectospat","category":"page"},{"location":"examples/torsionalmodes/#Assembly","page":"Torsional Alfvén modes","title":"Assembly","text":"","category":"section"},{"location":"examples/torsionalmodes/","page":"Torsional Alfvén modes","title":"Torsional Alfvén modes","text":"We can assemble the submatrices and concatenate them to get our final left hand side matrix LHS and right hand side matrix RHS.","category":"page"},{"location":"examples/torsionalmodes/","page":"Torsional Alfvén modes","title":"Torsional Alfvén modes","text":"Here, the non-dimensional parameters are the Lehnert number Le and the Lundquist number Lu. We give the resolution by an integer N, that determines the polynomial degree of our solutions. This function takes for B0 a collection of BasisElement's, as shown below.","category":"page"},{"location":"examples/torsionalmodes/","page":"Torsional Alfvén modes","title":"Torsional Alfvén modes","text":"function assemble(N, Le, Lu, B0)\n\tu = Inviscid(N; m=0)\n\tb = Insulating(N; m=0)\n\tLHS = blockdiag(sparse(Limace.inertial(u),length(u),length(u)), sparse(Limace.inertial(b)))\n\tRHSc = Limace.coriolis(u)/Le\n\tRHSl = sum(Limace.lorentz_threaded(u,b,B) for B in B0)\n\tRHSi = sum(Limace.induction_threaded(b,u,B) for B in B0)\n\tRHSd = Limace.diffusion(b)/Lu\n\tRHS = [RHSc RHSl\n\t\t   RHSi RHSd]\n\treturn LHS, RHS, u, b\nend","category":"page"},{"location":"examples/torsionalmodes/","page":"Torsional Alfvén modes","title":"Torsional Alfvén modes","text":"Define parameters and background magnetic field:","category":"page"},{"location":"examples/torsionalmodes/","page":"Torsional Alfvén modes","title":"Torsional Alfvén modes","text":"N = 100\nLe = 5e-4\nLu = 1/Le\nB0 = [BasisElement(Basis{Insulating}, Poloidal, (1,0,1),0.3), BasisElement(Basis{Insulating}, Poloidal, (2,0,1),0.7)]","category":"page"},{"location":"examples/torsionalmodes/","page":"Torsional Alfvén modes","title":"Torsional Alfvén modes","text":"This background field is a mix of two poloidal field components, l,m,n=(1,0,1) and l,m,n = (2,0,1), i.e. dipolar and quadrupolar symmetry.","category":"page"},{"location":"examples/torsionalmodes/","page":"Torsional Alfvén modes","title":"Torsional Alfvén modes","text":"Assemble the matrices:","category":"page"},{"location":"examples/torsionalmodes/","page":"Torsional Alfvén modes","title":"Torsional Alfvén modes","text":"LHS, RHS, u, b = assemble(N, Le, Lu, B0);\nnothing #hide","category":"page"},{"location":"examples/torsionalmodes/#Solve-the-eigen-problem","page":"Torsional Alfvén modes","title":"Solve the eigen problem","text":"","category":"section"},{"location":"examples/torsionalmodes/","page":"Torsional Alfvén modes","title":"Torsional Alfvén modes","text":"We can calculate some eigenvalues and vectors near a given target. For torsional modes it is sensible to choose a target near λ = -σ+im*ω = 1.0im, i.e. an Alfvén frequency of 1 (note: this only the case, when using the Alfvén time as the characteristic time-scale in the nondimensionalization).","category":"page"},{"location":"examples/torsionalmodes/","page":"Torsional Alfvén modes","title":"Torsional Alfvén modes","text":"target = 1.0im","category":"page"},{"location":"examples/torsionalmodes/","page":"Torsional Alfvén modes","title":"Torsional Alfvén modes","text":"Limace.jl provides the eigstarget function, based on shift-invert spectral transform and an implicitly restarted Arnoldi method. The keyword nev can be set to the desired number of eigenvalues.","category":"page"},{"location":"examples/torsionalmodes/","page":"Torsional Alfvén modes","title":"Torsional Alfvén modes","text":"λ, x = eigstarget(RHS, LHS, target; nev=5);\nnothing #hide","category":"page"},{"location":"examples/torsionalmodes/#Plot-the-solution","page":"Torsional Alfvén modes","title":"Plot the solution","text":"","category":"section"},{"location":"examples/torsionalmodes/","page":"Torsional Alfvén modes","title":"Torsional Alfvén modes","text":"We find the solution of largest real part, corresponding to the smallest damping rate. In this simple example this is enough to isolate the gravest torsional mode from the other calculated solutions.","category":"page"},{"location":"examples/torsionalmodes/","page":"Torsional Alfvén modes","title":"Torsional Alfvén modes","text":"per = sortperm(λ, by = real, rev=true);\n\nλ[per]","category":"page"},{"location":"examples/torsionalmodes/","page":"Torsional Alfvén modes","title":"Torsional Alfvén modes","text":"We discretize the corresponding eigenvector in the meridional plane. Since m=0, we do not need more than one value of the longitude.","category":"page"},{"location":"examples/torsionalmodes/","page":"Torsional Alfvén modes","title":"Torsional Alfvén modes","text":"nr, nθ, nϕ = 2N+1, 2N+1, 1\n\nur,uθ,uϕ, br,bθ,bϕ, r,θ,ϕ = spectospat(x[:,per[1]], u,b, nr,nθ,nϕ);\nnothing #hide","category":"page"},{"location":"examples/torsionalmodes/","page":"Torsional Alfvén modes","title":"Torsional Alfvén modes","text":"The meridional slices are plotted with CairoMakie.jl for example:","category":"page"},{"location":"examples/torsionalmodes/","page":"Torsional Alfvén modes","title":"Torsional Alfvén modes","text":"let\n\tf = Figure()\n\tfor (i,(comp, title)) in enumerate(zip((ur, uθ, uϕ),(L\"u_r\", L\"u_\\theta\", L\"u_\\phi\")))\n\t\tax = Axis(f[1,2i]; aspect=DataAspect(), title)\n\t\thidedecorations!(ax)\n\t\thidespines!(ax)\n\t\tx = r .* cos.(θ')\n\t\ty = r .* sin.(θ')\n\t\tz = real.(comp[:,:,1])\n\t\tclim = maximum(abs,z)\n\t\tcax = surface!(ax, x,y, z, colormap=:vik, colorrange=(-clim,clim),shading=NoShading)\n\t\tColorbar(f[1,2i-1],cax, flipaxis=false)\n\tend\n\tfor (i,(comp, title)) in enumerate(zip((br,bθ,bϕ),(L\"b_r\", L\"b_\\theta\", L\"b_\\phi\")))\n\t\tax = Axis(f[2,2i]; aspect=DataAspect(), title)\n\t\thidedecorations!(ax)\n\t\thidespines!(ax)\n\t\tx = r .* cos.(θ')\n\t\ty = r .* sin.(θ')\n\t\tz = real.(comp[:,:,1])\n\t\tclim = maximum(abs,z)\n\t\tcax = surface!(ax, x,y, z, colormap=:broc, colorrange=(-clim,clim),shading=NoShading)\n\t\tColorbar(f[2,2i-1],cax, flipaxis=false)\n\tend\n\n\tf\nend","category":"page"},{"location":"examples/torsionalmodes/","page":"Torsional Alfvén modes","title":"Torsional Alfvén modes","text":"","category":"page"},{"location":"examples/torsionalmodes/","page":"Torsional Alfvén modes","title":"Torsional Alfvén modes","text":"This page was generated using Literate.jl.","category":"page"}]
}
